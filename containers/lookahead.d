/**
 * lookahead.d contains the Lookahead class, which operates on ranges but is 
 * optimized for slices.
 *
 * Copyright: (C) 2012 Nathan M. Swan
 * Authors: Nathan M. Swan, aka carlor
 * License:	Boost Software License - Version 1.0
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

module dcaflib.containers.lookahead;

private {
    import std.array;
    import std.range;
    import std.traits;
}

/++
 + $(D Lookahead!Param) is an infinite lookahead of, if Param is a range, a
 + Param, else an array of Params.
 +/
public interface Lookahead(Param) {
    
    public:
    static if (isInputRange!Param) {
        alias Param R;
        alias ElementType!Param T;
    } else {
        alias Param[] R;
        alias Param T;
    }
    
    /// Consumes howmuch of the buffer.
    void consume(size_t howmuch=1);
    
    /// Loads in the buffer and gets howmuch of it, or the sentinel. 
    T get(size_t howmuch=0);
    
    /// Creates a new lookahead from the range that gives sentinel on empty.
    static Lookahead!Param create(R range, T sentinel = T.init) {
        static if (isDynamicArray!R) {
            return new class Lookahead!(Param) {
                private this() {
                    _array = range;
                    _sentinel = sentinel;
                }
                
                public void consume(size_t howmuch=1) {
                    if (howmuch < _array.length) {
                        _array = _array[howmuch .. $];
                    } else {
                        _array = [];
                    }
                }
                
                public T get(size_t howmuch=0) {
                    if (howmuch < _array.length) {
                        return _array[howmuch];
                    } else {
                        return _sentinel;
                    }
                }
                
                private T[] _array;
                private T _sentinel;
            };
        } else {
            return new class Lookahead!(Param) {
                private this() {
                    _range = range;
                    _buffer = [];
                    _sentinel = sentinel;
                }
                
                public void consume(size_t howmuch=1) {
                    if (howmuch < _buffer.length) {
                        _buffer = _buffer[howmuch .. $];
                    } else {
                        howmuch -= _buffer.length;
                        _buffer = [];
                        while(howmuch-- && !_range.empty) {
                            _range.popFront();
                        }
                    }
                }
                
                public T get(size_t howmuch=0) {
                    if (howmuch >= _buffer.length) {
                        updateBuffer(howmuch+1);
                    }
                    if (_buffer.length <= howmuch) {
                        return sentinel;
                    } else {
                        return _buffer[howmuch];
                    }
                }
                
                private void updateBuffer(size_t howmuch) {
                    howmuch -= _buffer.length;
                    while(howmuch && !_range.empty) {
                        _buffer ~= _range.front;
                        _range.popFront();
                        howmuch--;
                    }           
                }     
                
                private R _range;
                private T[] _buffer;
                private T _sentinel;                           
            };
        }
    }
}

unittest {
    string[] arr = ["hi", "bye", "foo", "bar", "baz"];
    Lookahead!(string[]) lah = Lookahead!(string[]).create(arr, "__END__");
    assert(lah.get() == "hi");
    assert(lah.get(1) == "bye");
    lah.consume(4);
    assert(lah.get() == "baz");
    lah.consume();
    assert(lah.get() == "__END__");
    lah.consume(100);
    assert(lah.get() == "__END__");
    
    struct NumberRange {
        uint front = 0;
        enum empty = false;
        void popFront() { front++; }
    }
    
    NumberRange nr;
    Lookahead!(NumberRange) ns = Lookahead!(NumberRange).create(nr);
    assert(ns.get(3) == 3);
    assert(ns.get(20) == 20);
    ns.consume(5);
    assert(ns.get(3) == 8);
    assert(ns.get(20) == 25);
}
